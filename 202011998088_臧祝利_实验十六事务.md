# 实验十六 事务

|  姓名  |     学号     |     学院     |   日期    |
| :----: | :----------: | :----------: | :-------: |
| 臧祝利 | 202011998088 | 人工智能学院 | 2022.12.5 |

## 实验目的

(1) 了解事务的概念和特性。

(2) 了解事务的隔离级别及并发控制。

## 实验环境

(1) 数据库管理系统：PostgreSQL。

(2) 图形化管理工具：pgAdmin。

## 实验内容

(1) 将多个SQL语句定义为一个事务，实现事务的提交与回滚。

(2) 为事务设置保存点，并实现事务提交与回滚。

(3) 并发执行多个事务，运行并分析隔离性。

## 实验数据

应急预案（`Emergency Plan`）指面对突发事件如自然灾害、事故灾难、公共卫生事件和社会安全事件等的应急管理、指挥、救援计划等，是一种公文。本次实验使用应急预案数据库。通常一个应急预案由多个不同的编制单位协同编写，才能编制完成。应急预案包含预案编号（`ep_id`），预案名（`ep_name`），针对的灾害类型（`ep_disatype`），针对的区域（`ep_area`），针对的灾害等级（`ep_level`），发布时间（`ep_date`）。应急预案编制的参与单位`org`包含单位编号（`org_id`），单位名称(`org_name`)，单位联系方式（`org_tel`）。一个参与单位可能参与多个预案的编制，一个预案需要多个参与单位协作完成。当参与单位完成编写应急预案时，会记录该单位在应急预案编制中的职责（`org_respon`）和工作量（`workload`）。

## 实验思路

请确认数据库`Emgyplan`中`org`表的结构和示例性数据如下:

==org表结构==

|   属性   |  类型   | 长度 |
| :------: | :-----: | :--: |
|  org_id  |   int   |      |
| org_name | varchar |  50  |
| org_tel  | varchar |  30  |

==org表中的数据==

| org_id |  org_name  | org_tel  |
| :----: | :--------: | :------: |
|   1    |   教育部   | 66096114 |
|   2    | 应急管理部 | 64463685 |
|   3    |   民政局   | 58123114 |
|   4    |   气象局   | 68409797 |

**Step1.** 新建一数据库，命名为`Emgyplan`;

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052222369.png" alt="image-20221205222207238" style="zoom:80%;" />

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052222795.png" alt="image-20221205222239722" style="zoom:80%;" />

**Step2.** 选择架构->表，右击选择新建表，取名为`org`

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052224421.png" alt="image-20221205222456345" style="zoom:80%;" />

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052225920.png" alt="image-20221205222520825" style="zoom:80%;" />

**Step3.** 设置属性名称及数据类型，将`org_id`设置为主键

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052227238.png" alt="image-20221205222708156" style="zoom:80%;" />

**Step4.** 右击表，选择查看/编辑数据->所有行，向数据库插入数据

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052228957.png" alt="image-20221205222806897" style="zoom:80%;" />

点击①添加行，输入数据；再点击②进行保存；

<img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052230106.png" alt="image-20221205223025046" style="zoom:80%;" />

- 显示开启一个事务，向`org`表中插入如下数据，并使用`ROLLBACK`进行事务回滚。 

  - 先把自动提交关闭；

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052245664.png" alt="image-20221205224531617" style="zoom:80%;" />

  - 输入代码

    ```sql
    BEGIN;
    INSERT INTO org VALUES(5,'财政部','68551114');
    ```

  - 运行后查看表的所有行，发现插入成功；

    ```sql
    SELECT * FROM org;
    ```

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052327622.png" alt="image-20221205232735564" style="zoom:80%;" />

  - 执行回滚操作，输入代码：

    ```sql
    ROLLBACK TRANSACTION;
    ```

  - 运行后查看表的所有行，

    ```sql
    SELECT * FROM org;
    ```

    与初始一样，说明回滚成功；

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052329531.png" alt="image-20221205232923476" style="zoom:80%;" />

- 显示开启一个事务，向org表中分别插入如下两行数据，并在第一条插入语句与第二条插入语句之间创建保存点，插入完成后将事务回滚到刚才的保存点。

  - 输入代码

    ```sql
    BEGIN;
    INSERT INTO org VALUES(6,'税务局','63417425');
    SAVEPOINT Insert6;
    INSERT INTO org VALUES(7,'统计局','68573311');
    ```

  - 执行后查询表，

    ```sql
    SELECT * FROM org;
    ```

    结果如图，二者都被插入

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052331755.png" alt="image-20221205233123696" style="zoom:80%;" />

  - 回滚，执行代码：

    ```sql
    ROLLBACK TO insert6;
    ```

  - 查询表

    ```sql
    SELECT * FROM org;
    ```

    结果如图，发生了回滚。

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052332203.png" alt="image-20221205233258141" style="zoom:80%;" />

  - COMMIT事务

    ```sql
    COMMIT;
    ```

- 在`Repeatable Read`事务隔离级别下开启事务1，查询`org`表中`org_tel=58123114`的记录；另开启一个事务2，向`org`表中插入如下数据并提交事务；再次在事务1中查询`org`表中`org_tel=58123114`的所有记录，观察查询结果是否有变化。 

  - 事务1，输入代码

    ```sql
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    BEGIN;
    SELECT * FROM org WHERE org_tel='58123114';
    ```

    输出为：

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052334398.png" alt="image-20221205233457342" style="zoom:80%;" />

  - 事务2，输入代码：

    ```sql
    BEGIN;
    INSERT INTO org VALUES(8,'民政部1','58123114');
    COMMIT;
    ```

    查看表内数据：

    ```sql
    SELECT * FROM org;
    ```

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052336142.png" alt="image-20221205233642084" style="zoom:80%;" />

  - 再次执行刚才的查询事务：

    ```sql
    -- SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    -- BEGIN;
    SELECT * FROM org WHERE org_tel='58123114';
    ```

    结果为：

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052339715.png" alt="image-20221205233757746" style="zoom:80%;" />

    结果没有发生变化，==原因==：使用了可重复读的隔离级别

  - COMMIT当前事务；

    ```sql
    COMMIT;
    ```

- 显示开启事务1，给`org`表加锁，只允许`org`表具有读操作，另开一个事务2，验证能否对`org`表进行插入操作并分析原因。(自行选择数据进行插入，没有固定要求) 

  - 加锁：

    ```sql
    BEGIN;
    LOCK TABLE org IN SHARE MODE;
    ```

  - 事务2，输入以下代码，执行插入操作：

    ```sql
    BEGIN;
    INSERT INTO org VALUES(114514,'民政部2','58123114');
    COMMIT;
    ```

    一直显示”正在等待查询完成“；==原因==：加锁之后，只运行其他事务对表进行读操作，而事务2为写操作，因此无法执行，只能处于等待状态；

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052346604.png" alt="image-20221205234630502" style="zoom:80%;" />

  - 提交事务1，发现事务2已经完成；

    ```sql
    -- BEGIN;
    -- LOCK TABLE org IN SHARE MODE;
    COMMIT;
    ```

    查看表中内容，发现插入成功；==原因==：事务1提交之后解除了锁，因此可以执行写操作，事务2可以执行；

    <img src="https://noteimg-12138.oss-cn-beijing.aliyuncs.com/img/202212052349522.png" alt="image-20221205234923459" style="zoom:80%;" />





